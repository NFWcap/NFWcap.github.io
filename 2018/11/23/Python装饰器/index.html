<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>Python装饰器 | 帽子不太白</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="帽子不太白">
    <meta name="author" content="Alex">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="帽子不太白" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://pwnable.kr/play.php" class="animsition-link">Pwnable.kr</a></li>
                    
                    <li><a href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">帽子不太白</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2018-11-23T02:11:46.000Z" itemprop="datePublished">
          2018-11-23
      </time>
    
    
    | 
    <a href='/tags/Python/'>Python</a>
    
    
</span>
                <h1>Python装饰器</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>转载一篇关于Python装饰器的文章，我认为讲的非常清晰，容易理解</p>
<a id="more"></a>
<p>在学习Python的过程中，我相信有很多人和我一样，对Python的装饰器一直觉得很困惑，我也是困惑了好久，并通过思考和查阅才能略有领悟，我希望以下的内容会对你有帮助，我也努力通过通俗的方式使得对Python装饰器的理解更加的透彻。在文中如有遗漏和不足，欢迎交流和指点。 </p>
<p>很多人都对装饰器难以理解，原因是由于以下三点内容没有搞清楚：</p>
<ul>
<li>关于函数“变量”（或“变量”函数）的理解</li>
<li>关于高阶函数的理解</li>
<li>关于嵌套函数的理解</li>
</ul>
<p>那么如果能对以上的问题一一攻破，同时遵循装饰器的基本原则，相信会对装饰器有个很好的理解的。那么我们先来看以下装饰器的目的及其原则。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器实际上就是为了给某程序增添功能，但该程序已经上线或已经被使用，那么就不能大批量的修改源代码，这样是不科学的也是不现实的，因为就产生了装饰器，使得其满足：</p>
<ol>
<li><p>不能修改被装饰的函数的源代码</p>
</li>
<li><p>不能修改被装饰的函数的调用方式</p>
</li>
<li><p>满足1、2的情况下给程序增添功能</p>
<p>那么根据需求，同时满足了这三点原则，这才是我们的目的。因为，下面我们从解决这三点原则入手来理解装饰器。</p>
</li>
</ol>
<p>等等，我要在需求之前先说装饰器的原则组成：</p>
<p><strong>&lt; 函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 = 装饰器 &gt;</strong></p>
<p>这个式子是贯穿装饰器的灵魂所在！</p>
<h2 id="需求的实现"><a href="#需求的实现" class="headerlink" title="需求的实现"></a>需求的实现</h2><p>假设有代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line">def test():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>很显然，这段代码运行的结果一定是：等待约2秒后，输出</p>
<blockquote>
<p>test is running</p>
</blockquote>
<ul>
<li>那么要求在满足三原则的基础上，给程序添加统计运行时间（2 <em>second</em>）功能</li>
</ul>
<p>在行动之前，我们先来看一下文章开头提到的原因1（关于函数“变量”（或“变量”函数）的理解）</p>
<h3 id="函数“变量”（或“变量”函数）"><a href="#函数“变量”（或“变量”函数）" class="headerlink" title="函数“变量”（或“变量”函数）"></a>函数“变量”（或“变量”函数）</h3><p>假设有代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br><span class="line">y = x</span><br><span class="line">def test1():</span><br><span class="line">    print(&quot;Do something&quot;)</span><br><span class="line">test2 = lambda x:x*2</span><br></pre></td></tr></table></figure>
<p>那么在内存中，应该是这样的：</p>
<p><img src="/2018/11/23/Python装饰器/1.jpg" alt="1"></p>
<p>很显然，函数和变量是一样的，都是“<strong>一个名字对应内存地址中的一些内容</strong>”<br>那么根据这样的原则，我们就可以理解两个事情：</p>
<ol>
<li><p>test1表示的是函数的内存地址</p>
</li>
<li><p>test1()就是调用对在test1这个地址的内容，即函数</p>
<p>如果这两个问题可以理解，那么我们就可以进入到下一个原因（关于高阶函数的理解）</p>
</li>
</ol>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>那么对于高阶函数的形式可以有两种：</p>
<ol>
<li><p>把一个函数名当作实参传给另外一个函数（“实参高阶函数”）</p>
</li>
<li><p>返回值中包含函数名（“返回值高阶函数”）</p>
<p>那么这里面所说的函数名，实际上就是函数的地址，也可以认为是函数的一个标签而已，并不是调用，是个名词。如果可以把函数名当做实参，那么也就是说可以把函数传递到另一个函数，然后在另一个函数里面做一些操作，根据这些分析来看，这岂不是满足了装饰器三原则中的第一条，即不修改源代码而增加功能。那我们看来一下具体的做法：</p>
</li>
</ol>
<p>还是针对上面那段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)</span><br><span class="line"></span><br><span class="line">def deco(func):  </span><br><span class="line">    start = time.time()</span><br><span class="line">    func() #2</span><br><span class="line">    stop = time.time()</span><br><span class="line">    print(stop-start)</span><br><span class="line"></span><br><span class="line">deco(test) #1</span><br></pre></td></tr></table></figure>
<p>我们来看一下这段代码，在#1处，我们把test当作实参传递给形参func，即func=test。注意，这里传递的是地址，也就是此时func也指向了之前test所定义的那个函数体，可以说在deco()内部，func就是test。在#2处，把函数名后面加上括号，就是对函数的调用（执行它）。因此，这段代码运行结果是：</p>
<blockquote>
<p>test is running! </p>
<p>the run time is 3.0009405612945557</p>
</blockquote>
<p>我们看到似乎是达到了需求，即执行了源程序，同时也附加了计时功能，但是这只满足了原则1（不能修改被装饰的函数的源代码），但这修改了调用方式。假设不修改调用方式，那么在这样的程序中，被装饰函数就无法传递到另一个装饰函数中去。</p>
<p>那么再思考，如果不修改调用方式，就是一定要有test()这条语句，那么就用到了第二种高阶函数，即返回值中包含函数名</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)</span><br><span class="line"></span><br><span class="line">def deco(func):  </span><br><span class="line">    print(func)</span><br><span class="line">    return func </span><br><span class="line">t = deco(test) #3</span><br><span class="line">#t()#4</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>我们看这段代码，在#3处，将test传入deco()，在deco()里面操作之后，最后返回了func，并赋值给t。因此这里test =&gt; func =&gt; t，都是一样的函数体。最后在#4处保留了原来的函数调用方式。 看到这里显然会有些困惑，我们的需求不是要计算函数的运行时间么，怎么改成输出函数地址了。是因为，单独采用第二张高阶函数（返回值中包含函数名）的方式，并且保留原函数调用方式，是无法计时的。如果在deco()里计时，显然会执行一次，而外面已经调用了test()，会重复执行。这里只是为了说明第二种高阶函数的思想，下面才真的进入重头戏。</p>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>嵌套函数指的是在函数内部定义一个函数，而不是调用，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    def func2():</span><br><span class="line">        pass</span><br><span class="line">而不是</span><br><span class="line">def func1():</span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure>
<p>另外还有一个题外话，<strong>函数只能调用和它同级别以及上级的变量或函数</strong>。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。</p>
<p>那么我们再回到我们之前的那个需求，想要统计程序运行时间，并且满足三原则。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def timer(func) #5</span><br><span class="line">    def deco():  </span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop-start)</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">test = timer(test) #6</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)   </span><br><span class="line">test() #7</span><br></pre></td></tr></table></figure>
<p>这段代码可能会有些困惑，怎么忽然多了这么多，暂且先接受它，分析一下再来说为什么是这样。</p>
<p>首先，在#6处，把test作为参数传递给了timer()，此时，在timer()内部，func = test，接下来，定义了一个deco()函数，当并未调用，只是在内存中保存了，并且标签为deco。在timer()函数的最后返回deco()的地址deco。</p>
<p>然后再把deco赋值给了test，那么此时test已经不是原来的test了，也就是test原来的那些函数体的标签换掉了，换成了deco。那么在#7处调用的实际上是deco()。</p>
<p>那么这段代码在本质上是修改了调用函数，但在表面上并未修改调用方式，而且实现了附加功能。</p>
<p>那么通俗一点的理解就是：</p>
<hr>
<p><strong>把函数看成是盒子，test是小盒子，deco是中盒子，timer是大盒子。程序中，把小盒子test传递到大盒子temer中的中盒子deco，然后再把中盒子deco拿出来，打开看看（调用）</strong></p>
<hr>
<p>这样做的原因是：</p>
<p>我们要保留test()，还要统计时间，而test()只能调用一次（调用两次运行结果会改变，不满足），再根据函数即“变量”，那么就可以通过函数的方式来回闭包。于是乎，就想到了，把test传递到某个函数，而这个函数内恰巧内嵌了一个内函数，再根据内嵌函数的作用域（可以访问同级及以上，内嵌函数可以访问外部参数），把test包在这个内函数当中，一起返回，最后调用这个返回的函数。而test传递进入之后，再被包裹出来，显然test函数没有弄丢（在包裹里），那么外面剩下的这个test标签正好可以替代这个包裹（内含test()）。</p>
<p><img src="/2018/11/23/Python装饰器/2.jpg" alt="2"></p>
<h2 id="真正的装饰器"><a href="#真正的装饰器" class="headerlink" title="真正的装饰器"></a>真正的装饰器</h2><p>根据以上分析，装饰器在装饰时，需要在每个函数前面加上：</p>
<blockquote>
<p>test = timer(test)</p>
</blockquote>
<p>显然有些麻烦，Python提供了一种语法糖，即：</p>
<blockquote>
<p>@timer</p>
</blockquote>
<p>这两句是等价的，只要在函数前加上这句，就可以实现装饰作用。</p>
<h2 id="装饰有参函数"><a href="#装饰有参函数" class="headerlink" title="装饰有参函数"></a>装饰有参函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def timer(func)</span><br><span class="line">    def deco():  </span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop-start)</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test(parameter): #8</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)   </span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>对于一个实际问题，往往是有参数的，如果要在#8处，给被修饰函数加上参数，显然这段程序会报错的。错误原因是test()在调用的时候缺少了一个位置参数的。而我们知道test = func = deco，因此test()=func()=deco() </p>
<p>那么当test(parameter)有参数时，就必须给func()和deco()也加上参数，为了使程序更加有扩展性，因此在装饰器中的deco()和func()，加如了可变参数*agrs和 **kwargs。</p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def timer(func)</span><br><span class="line">    def deco(*args, **kwargs):  </span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop-start)</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test(parameter): #8</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)   </span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>那么我们再考虑个问题，如果原函数test()的结果有返回值呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(parameter): </span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)   </span><br><span class="line">    return &quot;Returned value&quot;</span><br></pre></td></tr></table></figure>
<p>那么面对这样的函数，如果用上面的代码来装饰，最后一行的test()实际上调用的是deco()。有人可能会问，func()不就是test()么，怎么没返回值呢？</p>
<p>其实是有返回值的，但是返回值返回到deco()的内部，而不是test()即deco()的返回值，那么就需要再返回func()的值，因此就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def timer(func)</span><br><span class="line">    def deco(args, **kwargs):  </span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(args, **kwargs)#9</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop-start)</span><br><span class="line">        return res#10</span><br><span class="line">return deco</span><br></pre></td></tr></table></figure>
<p>其中，#9的值在#10处返回。</p>
<p>完整程序为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line">def timer(func)</span><br><span class="line">    def deco(*args, **kwargs):  </span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop-start)</span><br><span class="line">        return res </span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test(parameter): #8</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;test is running!&quot;)   </span><br><span class="line">    return &quot;Returned value&quot;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>又增加了一个需求，一个装饰器，对不同的函数有不同的装饰。那么就需要知道对哪个函数采取哪种装饰。因此，就需要装饰器带一个参数来标记一下。例如：</p>
<blockquote>
<p>@decorator(parameter = value)</p>
</blockquote>
<p>比如有两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def task1():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task1&quot;)</span><br><span class="line"></span><br><span class="line">def task2():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task2&quot;)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure>
<p>要对这两个函数分别统计运行时间，但是要求统计之后输出：</p>
<blockquote>
<p>the task1/task2 run time is : 2.00……</p>
</blockquote>
<p>于是就要构造一个装饰器timer，并且需要告诉装饰器哪个是task1，哪个是task2，也就是要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@timer(parameter=&apos;task1&apos;) #</span><br><span class="line">def task1():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task1&quot;)</span><br><span class="line"></span><br><span class="line">@timer(parameter=&apos;task2&apos;) #</span><br><span class="line">def task2():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task2&quot;)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure>
<p>那么方法有了，但是我们需要考虑如何把这个<em>parameter</em>参数传递到装饰器中，我们以往的装饰器，都是传递函数名字进去，而这次，多了一个参数，要怎么做呢？<br>于是，就想到再加一层函数来接受参数，根据嵌套函数的概念，要想执行内函数，就要先执行外函数，才能调用到内函数，那么就有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def timer(parameter): #</span><br><span class="line">    print(&quot;in the auth :&quot;, parameter)</span><br><span class="line"></span><br><span class="line">    def outer_deco(func): #</span><br><span class="line">        print(&quot;in the outer_wrapper:&quot;, parameter)</span><br><span class="line"></span><br><span class="line">        def deco(*args, **kwargs):</span><br><span class="line"></span><br><span class="line">        return deco</span><br><span class="line"></span><br><span class="line">    return outer_deco</span><br></pre></td></tr></table></figure>
<p>首先timer(parameter)，接收参数<em>parameter</em>=’task1/2’，而@timer(parameter)也恰巧带了括号，那么就会执行这个函数， 那么就是相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer = timer(parameter)</span><br><span class="line">task1 = timer(task1)</span><br></pre></td></tr></table></figure>
<p>后面的运行就和一般装饰器一样了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(parameter):</span><br><span class="line"></span><br><span class="line">    def outer_wrapper(func):</span><br><span class="line"></span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            if parameter == &apos;task1&apos;:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                print(&quot;the task1 run time is :&quot;, stop - start)</span><br><span class="line">            elif parameter == &apos;task2&apos;:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                print(&quot;the task2 run time is :&quot;, stop - start)</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return outer_wrapper</span><br><span class="line"></span><br><span class="line">@timer(parameter=&apos;task1&apos;)</span><br><span class="line">def task1():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task1&quot;)</span><br><span class="line"></span><br><span class="line">@timer(parameter=&apos;task2&apos;)</span><br><span class="line">def task2():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;in the task2&quot;)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure>
<hr>
<p>作者：LKaiiCn<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/u013471155/article/details/68960244" target="_blank" rel="noopener">https://blog.csdn.net/u013471155/article/details/68960244</a> </p>
<h2 id="多个装饰器的执行顺序"><a href="#多个装饰器的执行顺序" class="headerlink" title="多个装饰器的执行顺序"></a>多个装饰器的执行顺序</h2><p>当有两个或两个以上装饰器装饰一个函数的时候，那么执行流程和装饰的结果是什么原理呢，</p>
<p>我认为可以使用我们上面学习的的<strong>装进盒子</strong>的理论来帮助我们理解</p>
<p>我们使用下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def zs1(fun):</span><br><span class="line">    print(&apos;----ZS1----&apos;)</span><br><span class="line">    def inner1():</span><br><span class="line">        print(&apos;[1]&apos;)</span><br><span class="line">        return &apos;&lt;b&gt;&apos; + fun() + &apos;&lt;/b&gt;&apos;</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def zs2(fun):</span><br><span class="line">    print(&apos;----ZS2----&apos;)</span><br><span class="line">    def inner2():</span><br><span class="line">        print(&apos;[2]&apos;)</span><br><span class="line">        return &apos;&lt;i&gt;&apos; + fun() + &apos;&lt;/i&gt;&apos;</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@zs1</span><br><span class="line">@zs2</span><br><span class="line">def test():</span><br><span class="line">    print(&apos;----test----&apos;)</span><br><span class="line">    print(&apos;----[3]----&apos;)</span><br><span class="line">    return &apos;hello word&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = test()</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----ZS2----</span><br><span class="line">----ZS1----</span><br><span class="line">[1]</span><br><span class="line">[2]</span><br><span class="line">----test----</span><br><span class="line">----[3]----</span><br><span class="line">&lt;b&gt;&lt;i&gt;hello word&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure>
<p>根据结果判断可以发现，装饰器<code>zs2</code>先进行了装饰，然后第一个装饰器<code>zs1</code>在进行了装饰，而在调用过成功，先调用了第一个装饰器，在调用了第二个装饰器。</p>
<p>具体分析</p>
<ul>
<li><p>在执行到<code>@zs1</code>的时候，需要对下面的函数进行装饰，此时解释器继续往下走，发现并不是一个函数名，而是另一个装饰器，这个时候<code>zs1</code>就停下来，接着执行<code>zs2</code>，然后把<code>test</code>函数名传入装饰器中，这个时候可以理解为，<code>test</code>是小盒子，装入了大盒子<code>zs2</code>的中盒子<code>inner2</code>中，这个时候打印了<code>----ZS2----</code>紧接着，装饰完后，大盒子<code>zs1</code>开始进行装饰，把之前所有装好的盒子（<code>test1</code>–&gt;<code>inner2</code>–&gt;<code>zs2</code>）全部装入大盒子<code>zs1</code>的中盒子<code>inner1</code>,这个时候<code>zs1</code>开始运行进行装饰，所以打印<code>----ZS1----</code></p>
</li>
<li><p>然后开始调用<code>test</code>函数的时候，根据调用理论，就是把“盒子”拿出来，这个时候要先打开中盒子<code>inner1</code>所以先打印了<code>[1]</code>，再打开<code>inner2</code>,所以后打印<code>[2]</code>，得到<code>test</code>盒子，这个时候打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----test----</span><br><span class="line">----[3]----</span><br></pre></td></tr></table></figure>
<p>所以在一层层调完之后，打印的结果为<code>&lt;b&gt;&lt;i&gt;hello word&lt;/i&gt;&lt;/b&gt;</code> 。</p>
</li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2018/11/22/Git学习笔记-四/">
        Git学习笔记(四) →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Alex. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
